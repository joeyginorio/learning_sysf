\documentclass[11pt]{article}
\usepackage[a4paper, margin=1.15in]{geometry} 

%load any additional packages
\usepackage{amsmath,amsthm,amssymb,amsfonts,wasysym,bussproofs}
\usepackage{booktabs,changepage}
\usepackage{lipsum}


% Lambda Calculus Macros
\newcommand{\lam}{\lambda}


% New abstract environment
\renewenvironment{abstract}
    {\begin{adjustwidth}{1.0em}{1.0em}\underline{\textsc{Abstract}}\\}
    {\end{adjustwidth}}

\renewenvironment{proof}
    {\begin{adjustwidth}{1.5em}{1.5em}\textit{Proof.}}
    {\qed\\\end{adjustwidth}}
    
\newtheoremstyle{mytheoremstyle} % name
    {\topsep}                    % Space above
    {\topsep}                    % Space below
    {\itshape}                   % Body font
    {}                 % Indent amount
    {\bfseries}                  % Theorem head font
    {.}                          % Punctuation after theorem head
    {\newline}                      % Space after theorem head
    {}                           % Theorem head spec (can be left empty, meaning ‘normal’)
\theoremstyle{mytheoremstyle}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[section]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatletter
\renewcommand{\maketitle}{\bgroup\setlength{\parindent}{0pt}
\begin{flushleft}
  \textbf{\@title}

  \@author
  
  \textit{\@date}
\end{flushleft}\egroup
}
\makeatother
\title{\huge Learning in System F}
\author{\textsc{Joey Velez-Ginorio} \vspace{0.2cm}}
\date{\small\today}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle

\begin{abstract}
We show that in addition to typing and generation, learning is natural in System F. That is, we can learn programs in System F without adding anything to the language. After briefly discussing System F and generation, we formalize learning as a relation and prove that certain programs can be learned in System F. We end on the conjecture that \textit{any} program can be learned in System F (to be proved, hopefully soon).
\end{abstract}

\section{System F}
System F is an extension of the simply typed lambda calculus, discovered independently by both Jean-Yves Girard and John C. Reynolds in the early 1970's. It imbues the simply typed lambda calculus with polymorphism, the ability to abstract over types. 

Polymorphism lets the same program work with several types. For instance, consider \textsc{identity}, which returns its input. Without polymorphism, we need a new \textsc{identity} for each type we deal with, like natural numbers or booleans. With polymorphism it's possible to build a generic \textsc{identity} which works over any type---a feat impossible in the simply typed lambda calculus.\\

\begin{figure}[ht]
\centering
\setlength{\tabcolsep}{12pt}
\begin{tabular}{l  r}
\specialrule{.1em}{0em}{.2em}

\specialrule{.1em}{0em}{1em}
    \Large \textsc{Syntax} & \\
    & \\
    \begin{math}
    \setlength{\jot}{-2pt}
    \begin{aligned}
    e ::= \;& && \hspace*{.25in} \textsc{terms:}\\
        & x && \hspace*{.25in} \textit{variable}\\
        & e_1e_2 && \hspace*{.25in} \textit{application}\\
        & \lam x {:} \tau.e && \hspace*{.25in} \textit{abstraction}\\
        & e\lceil\tau\rceil && \hspace*{.25in} \textit{type application}\\    
        & \Lambda\alpha.e && \hspace*{.25in} \textit{type abstraction}\\
    \\
    v ::= \;& && \hspace*{.25in} \textsc{values:} \\
        & \lam x {:}\tau.e && \hspace*{.25in} \textit{abstraction}\\
        & \Lambda\alpha.e && \hspace*{.25in} \textit{type abstraction}\\
    \end{aligned}
    \end{math} & 
    \begin{math}
    \setlength{\jot}{-2pt}
    \begin{aligned}
    \tau ::= \;& && \hspace*{.25in} \textsc{types:}\\
        & \tau_1 \to \tau_2 && \hspace*{.25in} \textit{function type}\\
        & \forall\alpha.\tau && \hspace*{.25in} \textit{polymorphic type}\\
        & \alpha && \hspace*{.25in} \textit{type variable}\\
    \\
    \Gamma ::= \;& && \hspace*{.25in} \textsc{contexts:}\\
        & \cdot && \hspace*{.25in} \textit{empty}\\
        & x{:}\tau,\Gamma && \hspace*{.25in} \textit{variable}\\
        & \alpha{:}*,\Gamma && \hspace*{.25in} \textit{type variable}
    \end{aligned}
    \end{math}\\
    &\\
\specialrule{.1em}{1em}{0em}
\end{tabular}
\caption{Syntax of System F}
    \label{fig:syntax}
\end{figure}

Yet generic \textsc{identity} only hints at System F's expressive power. Polymorphism also lets you encode many useful types within System F. As opposed to introducing complex types explicitly, System F naturally encodes types like product, sum, and list. And with these types, we will see that System F has all it needs to learn programs from examples.

\section{Generating in System F}

You can't learn a program if you can't generate it. And if we're interested in learning any program in System F, we ought to ensure we can generate it. Thankfully, from System F's typing relation (Figure \ref{fig:typing}) we can derive an equivalent generating relation (Figure \ref{fig:generating}). That is, every well-typed program can be generated---and generated programs are sound with respect to the types they were generated from. 
\begin{quote}
    \centering
    $\Gamma \vdash \tau \rightsquigarrow e$\\
    \textit{"Given a context $\,\Gamma$ and type $\tau$, I can generate program $e$."}
\end{quote}
From theorems \ref{completeness-generating} and \ref{soundness-generating}, it follows that generating is equivalent to typing.
\begin{theorem}[\textsc{Completeness of Generating}]
If $\,\Gamma \vdash e : \tau$ then $\,\Gamma \vdash \tau \rightsquigarrow e$
\label{completeness-generating}
\end{theorem}
\begin{proof}
Induction on the generating rules.
\end{proof}
\begin{theorem}[\textsc{Soundness of Generating}]
If $\,\Gamma \vdash \tau \rightsquigarrow e$ then $\Gamma \vdash e : \tau$
\label{soundness-generating}
\end{theorem}
\begin{proof}
Induction on the typing rules.
\end{proof}

Versions of the generating relation are the crux of recent type driven work in program synthesis and automated theorem proving, e.g. MYTH, Idris, Synquid. The types are typically more expressive, but the aim is the same. Use types to guide generation of programs, proofs.

Moreover, generating is natural in System F. It requires no additional machinery from System F. In some sense, this is unsurprising. Theorems \ref{completeness-generating} and \ref{soundness-generating} show that typing and generating are equivalent, and typing is certainly natural in System F by definition.\\

\begin{figure}[h]
\centering
\setlength{\tabcolsep}{12pt}
\begin{tabular}{l r  l r}
\specialrule{.1em}{0em}{.2em}
\specialrule{.1em}{0em}{1em}
    \Large \textsc{Typing} & 
    &  & \framebox{$\Gamma \vdash e : \tau$}\\
    & & \\
    \multicolumn{2}{c}{
    \def\extraVskip{4pt}
    \def\labelSpacing{4pt}
    \def\defaultHypSeparation{\hskip .05in}
        \AxiomC{$x:\tau \in \Gamma$}
            \RightLabel{\textsc{(T-Var)}}
        \UnaryInfC{$\Gamma \vdash x : \tau$}
        \DisplayProof
    } &
    \multicolumn{2}{c}{
    \def\extraVskip{4pt}
    \def\labelSpacing{4pt}
    \def\defaultHypSeparation{\hskip .05in}
        \AxiomC{$\Gamma,\alpha \vdash e : \tau$}
            \RightLabel{\textsc{(T-TAbs)}}
        \UnaryInfC{$\Gamma \vdash \lam \alpha.e:\forall\alpha.\tau$}
        \DisplayProof
    }
    \\
    & &\\
    \multicolumn{2}{c}{
    \def\extraVskip{4pt}
    \def\labelSpacing{4pt}
    \def\defaultHypSeparation{\hskip .05in}
        \AxiomC{$\Gamma,x{:}\tau_1 \vdash e_2 : \tau_2$}
            \RightLabel{\textsc{(T-Abs)}}
        \UnaryInfC{$\Gamma \vdash \lam x{:}\tau_1.e_2:\tau_1 \to \tau_2$}
        \DisplayProof
    } &
    \multicolumn{2}{c}{
    \def\extraVskip{4pt}
    \def\labelSpacing{4pt}
    \def\defaultHypSeparation{\hskip .05in}
        \AxiomC{$\Gamma \vdash e : \forall\alpha.\tau_1$}
            \RightLabel{\textsc{(T-TApp)}}
        \UnaryInfC{$\Gamma \vdash e[\tau_2] : [\tau_2/\alpha]\tau_1$}
        \DisplayProof
    }
    \\
    & &\\
    \multicolumn{2}{c}{
    \def\extraVskip{4pt}
    \def\labelSpacing{4pt}
    \def\defaultHypSeparation{\hskip .05in}
        \AxiomC{$\Gamma \vdash e_1 : \tau_1 \to \tau_2$}
        \AxiomC{$\Gamma \vdash e_2 : \tau_1$}
            \RightLabel{\textsc{(T-App)}}
        \BinaryInfC{$\Gamma \vdash e_1e_2 : \tau_2$}
        \DisplayProof
    } \\
    & \\
\specialrule{.1em}{1em}{0em}
\end{tabular}
\caption{Typing in System F}
    \label{fig:typing}
\end{figure}

\begin{figure}[ht]
\centering
\setlength{\tabcolsep}{12pt}
\begin{tabular}{l r  l r}
\specialrule{.1em}{0em}{.2em}
\specialrule{.1em}{0em}{1em}
    \Large \textsc{Generating} & 
    &  & \framebox{$\Gamma \vdash \tau \rightsquigarrow e$}\\
    & & \\
    \multicolumn{2}{c}{
    \def\extraVskip{4pt}
    \def\labelSpacing{4pt}
    \def\defaultHypSeparation{\hskip .05in}
        \AxiomC{$x:\tau \in \Gamma$}
            \RightLabel{\textsc{(G-Var)}}
        \UnaryInfC{$\Gamma \vdash \tau \rightsquigarrow x$}
        \DisplayProof
    } &
    \multicolumn{2}{c}{
    \def\extraVskip{4pt}
    \def\labelSpacing{4pt}
    \def\defaultHypSeparation{\hskip .05in}
        \AxiomC{$\Gamma,\alpha \vdash \tau \rightsquigarrow e$}
            \RightLabel{\textsc{(G-TAbs)}}
        \UnaryInfC{$\Gamma \vdash \forall\alpha.\tau \rightsquigarrow \lam \alpha.e$}
        \DisplayProof
    }
    \\
    & &\\
    \multicolumn{2}{c}{
    \def\extraVskip{4pt}
    \def\labelSpacing{4pt}
    \def\defaultHypSeparation{\hskip .05in}
        \AxiomC{$\Gamma,x{:}\tau_1 \vdash \tau_2 \rightsquigarrow e_2$}
            \RightLabel{\textsc{(G-Abs)}}
        \UnaryInfC{$\Gamma \vdash \tau_1 \to \tau_2 \rightsquigarrow \lam x{:}\tau_1.e_2$}
        \DisplayProof
    } &
    \multicolumn{2}{c}{
    \def\extraVskip{4pt}
    \def\labelSpacing{4pt}
    \def\defaultHypSeparation{\hskip .05in}
        \AxiomC{$\Gamma \vdash \forall\alpha.\tau_1 \rightsquigarrow e$}
            \RightLabel{\textsc{(G-TApp)}}
        \UnaryInfC{$\Gamma \vdash [\tau_2/\alpha]\tau_1 \rightsquigarrow e[\tau_2]$}
        \DisplayProof
    }
    \\
    & &\\
    \multicolumn{2}{c}{
    \def\extraVskip{4pt}
    \def\labelSpacing{4pt}
    \def\defaultHypSeparation{\hskip .05in}
        \AxiomC{$\Gamma \vdash \tau_1 \to \tau_2 \rightsquigarrow e_1$}
        \AxiomC{$\Gamma \vdash \tau_1 \rightsquigarrow e_2$}
            \RightLabel{\textsc{(G-App)}}
        \BinaryInfC{$\Gamma \vdash \tau_2 \rightsquigarrow e_1e_2$}
        \DisplayProof
    } \\
    & \\
\specialrule{.1em}{1em}{0em}
\end{tabular}
\caption{Generating in System F}
    \label{fig:generating}
\end{figure}

\begin{section}{Learning}
However, what's surprising is that we can amend the generating relation to learn programs from examples. And without adding anything to System F. In other words,
\begin{quote}
\centering
    \textit{Learning is natural in System F.}
\end{quote}

This insight escapes recent work in program synthesis, which add machinery to languages in order to support learning. This can be convenient, and even necessary, depending on the class of programs you want to learn. But what we will see is that this machinery isn't necessary for a large class of programs, those expressible in System F.

The generating relation tells us that with a context and type, we can generate a program. But without more expressive types, or others ways of specifying what we want, the generating relation doesn't guarantee we generate a program we actually want. For example, suppose I want a program which takes a natural number and returns it, \textsc{identity}. Its type is $nat \!\to\! nat$. But so is a program which doubles a natural number. Hence we need better ways to guide generation to the program we want. 

Enter examples. Suppose again I want to generate \textsc{identity}. But this time in addition to its type, I provide examples of its behavior: $1$ returns $1$ and $2$ returns $2$. Now clearly this program isn't doubling its input. The trick then is how to define a learning relation which guides generation using examples.

Informally, let's introduce the learning relation and walk through how we would use it.
\begin{quote}
    \centering
    $\Gamma \vdash \tau \rhd \chi \rightsquigarrow e$\\
    \textit{"Given a context $\,\Gamma$, type $\tau$, and examples $\chi$, I can learn program $e$."}
\end{quote}
With this relation, we can ask whether \textsc{identity} is learnable given a context, type, and examples:
$$\cdot \vdash nat \!\to\! nat \rhd \langle\langle1,1\rangle,\langle2,2\rangle\rangle \rightsquigarrow \blacksquare$$
Examples are stored as tuples. They describe possible worlds, one where our program's input is 1 and the other where our program's input is 2. Throughout learning we need a way to keep track of these distinct worlds. So our first step is always to duplicate $\blacksquare$, so that there is one per example.
$$\cdot \vdash list \,nat \!\to\! nat \rhd \langle\langle1,1\rangle,\langle2,2\rangle\rangle \rightsquigarrow [\blacksquare, \blacksquare]$$
Let's refine these worlds, by applying them to their respective inputs. We extract the inputs from each example tuple.
$$1{:}nat, 2{:}nat \vdash list \,nat \rhd \langle\langle1\rangle,\langle2\rangle\rangle \rightsquigarrow [(\blacksquare)1, (\blacksquare)2]$$
Because $\blacksquare$ is applied to an argument, we know it must be an abstraction. Hence, we can also claim:
$$1{:}nat, 2{:}nat \vdash list \,nat \rhd \langle\langle1\rangle,\langle2\rangle\rangle \rightsquigarrow [(\lam x{:}nat.\blacksquare)1, (\lam x{:}nat.\blacksquare)2]$$
Now that we've ran out of inputs in our examples, the problem becomes how to generate a program which satisfy the outputs left in the example tuples:
$$1{:}nat, 2{:}nat \vdash list \,nat\, \rightsquigarrow [(\lam x{:}nat.\blacksquare)1, (\lam x{:}nat.\blacksquare)2]$$
$$(\lam x{:}nat.\blacksquare)1 =_\beta 1\;\land\;(\lam x{:}nat.\blacksquare)2=_\beta2$$
Given the constraints on well-typed terms, it's easy to find $x$ to fill the body of the abstraction. This will become clear in the formal proof to follow.
$$1{:}nat, 2{:}nat \vdash list \,nat\, \rightsquigarrow [(\lam x{:}nat.x)1, (\lam x{:}nat.x)2]$$
$$(\lam x{:}nat.x)1 =_\beta 1\;\land\;(\lam x{:}nat.x)2=_\beta2$$
Having satisfied the outputs from our examples, we've informally shown $\textsc{identity} \equiv \lam x{:}nat.x$ is learnable in System F. And all the machinery comes from types and operators we can encode in System F: list and product types along with their constructors and deconstructors.\\

\begin{figure}[h!]
\centering
\setlength{\tabcolsep}{12pt}
\begin{tabular}{l r}
\specialrule{.1em}{0em}{.2em}
\specialrule{.1em}{0em}{1em}
    \Large \textsc{Learning} & 
    \framebox{$\Gamma \vdash \tau \rhd \chi \rightsquigarrow e$}\\
    & \\
    \multicolumn{2}{c}{
    \def\extraVskip{4pt}
    \def\labelSpacing{4pt}
    \def\defaultHypSeparation{\hskip .4in}
        \AxiomC{$\Gamma \vdash list \,\tau \rhd [\chi_1,\dots,\chi_n] \rightsquigarrow [e_1,\dots,e_n]$}
        \AxiomC{$\bigwedge_{i=1}^n e =_\beta e_n$}
        \RightLabel{\textsc{(L-Wrld)}}
        \BinaryInfC{$\Gamma \vdash \tau \rhd [\chi_1,\dots,\chi_n] \rightsquigarrow e$}
        

        \DisplayProof
    } \\\\
    \multicolumn{2}{c}{
    \def\extraVskip{4pt}
    \def\labelSpacing{4pt}
    \def\defaultHypSeparation{\hskip .4in}
        \AxiomC{$\Gamma, \bigcup_{i=1}^n \chi_i{:}\tau \vdash list \,\tau \rightsquigarrow [e_1,\dots,e_n]$}
        \AxiomC{$\bigwedge_{i=1}^{n} e_i =_\beta \chi_i$}
            \RightLabel{\textsc{(L-Gen)}}
        \BinaryInfC{$\Gamma \vdash list \,\tau \rhd [\chi_1,\dots,\chi_n] \rightsquigarrow [e_1,\dots,e_n]$}
        

        \DisplayProof
    } \\\\
    \multicolumn{2}{c}{
    \def\extraVskip{4pt}
    \def\labelSpacing{4pt}
    \def\defaultHypSeparation{\hskip .4in}
        \AxiomC{$\Gamma, \bigcup_{i=1}^n\pi_1(\chi_i){:}\tau_a \vdash list \,\tau_b \rhd [\pi_2(\chi_1),\dots,\pi_2(\chi_n)] \rightsquigarrow [e_1\pi_1(\chi_1),\dots,e_n\pi_1(\chi_n)]$}
        \RightLabel{\textsc{(L-Abs)}}
        \UnaryInfC{$\Gamma \vdash list \,\tau_{a} \!\to\! \tau_b \rhd [\chi_1,\dots,\chi_n] \rightsquigarrow [e_1,\dots,e_n]$}
        \DisplayProof
    } \\\\
    \multicolumn{2}{c}{
    \def\extraVskip{4pt}
    \def\labelSpacing{4pt}
    \def\defaultHypSeparation{\hskip .4in}
        \AxiomC{$\Gamma, \alpha \vdash list \,\tau \rhd [\chi_1,\dots,\chi_n] \rightsquigarrow [e_1\lceil\alpha\rceil,\dots,e_n\lceil\alpha\rceil]$}
        \RightLabel{\textsc{(L-TAbs)}}
        \UnaryInfC{$\Gamma \vdash list \,\forall\alpha.\tau \rhd [\Lambda\alpha.\chi_1,\dots,\Lambda\alpha.\chi_n] \rightsquigarrow [e_1,\dots,e_n]$}
        \DisplayProof
    } \\\\
    \multicolumn{2}{c}{
    \def\extraVskip{1pt}
    \def\labelSpacing{4pt}
    \def\defaultHypSeparation{\hskip .4in}
    \alwaysNoLine
        \AxiomC{$\Gamma\vdash list \,\tau_{a} \!\to\! \tau_c \rhd [\chi_1,\dots,\chi_j] \rightsquigarrow [e_1,\dots,e_j]$}
        \UnaryInfC{$\Gamma\vdash list \,\tau_{b} \!\to\! \tau_c \rhd [\chi_1,\dots,\chi_k] \rightsquigarrow [e_1,\dots,e_k]$}
        \RightLabel{\textsc{(L-Sum)}}
        \alwaysSingleLine
        \def\extraVskip{4pt}
        \UnaryInfC{$\Gamma \vdash list \,\tau_{a+b} \!\to\! \tau_c \rhd [\chi_1,\dots,\chi_n] \rightsquigarrow [e_1,\dots,e_n]$}
        \DisplayProof
    } \\
    & \\
\specialrule{.1em}{1em}{0em}
\end{tabular}
\caption{Learning in System F}
    \label{fig:learning}
\end{figure}

Before formally proving $\textsc{identity} \equiv \lam x{:}nat.x$ is learnable in System F, let's discuss the learning relation in Figure \ref{fig:learning}. Note that we assume the typical encodings for lists and tuples in System F. Brackets, [], denote lists. $\pi_1$ and $\pi_2$ denote the first and second projections of a tuple.

\textsc{(L-Wrld)} creates $n$ worlds from $n$ examples at the start of learning. These $n$ worlds allow us to keep track of constraints provided by the $n$ examples. 

\textsc{(L-Gen)} generates a program which satisfies all example outputs. This is done after passing the example inputs to their respective worlds.

\textsc{(L-Abs)} applies inputs to their respective worlds, by extracting the input from the example tuples.

\textsc{(L-TAbs)} applies polymorphic inputs to their respective worlds, by extracting the polymorphic input from the example tuples.

\textsc{(L-Sum)} distributes examples according to the types comprising a sum type. So if $bool$ is a sum type, equivalent to $true + false$. Then all examples whose next input is type $true$ will be sent off to a new sub-problem, the same with $false$. This helps to simplify the learning process, because each sub-problem only needs to worry about satisfying a smaller number of examples.

The next few proofs illustrate how we use these rules to learn programs. \textbf{Note that we assume typing (equivalently, generating) rules for product and list types as presented in TAPL (sections 11.6 and 11.2). Their derivations will be shown in the thesis).}

\begin{theorem}[\textsc{Learning \textsc{identity}}]
$\cdot \vdash nat \!\to\! nat \rhd \langle\langle1,1\rangle,\langle2,2\rangle\rangle \rightsquigarrow \lam x{:}nat.x$
\label{learning-identity}
\end{theorem}
\begin{proof}

\begin{prooftree}
\def\extraVskip{4pt}
\def\labelSpacing{4pt}
    \AxiomC{$x{:}nat \in 1{:}nat,2{:}nat,x{:}nat$}
    \RightLabel{\textsc{(G-Var)}}
    \UnaryInfC{$1{:}nat,2{:}nat,x{:}nat \vdash nat\!\to\!nat \rightsquigarrow x$}
    \RightLabel{\textsc{(G-Abs)}}
    \UnaryInfC{$1{:}nat,2{:}nat \vdash nat \rightsquigarrow \lam x{:}nat.x$}
    \AxiomC{$1{:}nat \in 1{:}nat,2{:}nat$}
    \RightLabel{\textsc{(G-Var)}}
    \UnaryInfC{$1{:}nat,2{:}nat \vdash nat \rightsquigarrow 1$}
    \RightLabel{\textsc{(G-App)}}
    \BinaryInfC{$1{:}nat,2{:}nat \vdash nat \rightsquigarrow (\lam x{:}nat.x)1$}
    \alwaysNoLine
    \UnaryInfC{}
\end{prooftree}


\begin{prooftree}
\def\extraVskip{4pt}
\def\labelSpacing{4pt}
    \AxiomC{$x{:}nat \in x{:}nat$}
    \RightLabel{\textsc{(G-Var)}}
    \UnaryInfC{$1{:}nat,2{:}nat,x{:}nat \vdash nat\!\to\!nat \rightsquigarrow x$}
    \RightLabel{\textsc{(G-Abs)}}
    \UnaryInfC{$1{:}nat,2{:}nat \vdash nat \rightsquigarrow \lam x{:}nat.x$}
    \AxiomC{$2{:}nat \in 2{:}nat$}
    \RightLabel{\textsc{(G-Var)}}
    \UnaryInfC{$1{:}nat,2{:}nat \vdash nat \rightsquigarrow 2$}
    \RightLabel{\textsc{(G-App)}}
    \BinaryInfC{$1{:}nat,2{:}nat \vdash nat \rightsquigarrow (\lam x{:}nat.x)2$}
    \alwaysNoLine
    \UnaryInfC{}
\end{prooftree}

\begin{prooftree}
\def\extraVskip{4pt}
\def\labelSpacing{4pt}
    \AxiomC{$\cdots$}
    \UnaryInfC{$1{:}nat,2{:}nat \vdash nat \rightsquigarrow (\lam x{:}nat.x)2$}
    \AxiomC{$1{:}nat,2{:}nat \vdash list \,nat \rightsquigarrow [\,]$}
    \RightLabel{\textsc{(G-Cons)}}
    \BinaryInfC{$1{:}nat,2{:}nat \vdash list \,nat \rightsquigarrow [(\lam x{:}nat.x)2]$}
    \alwaysNoLine
    \UnaryInfC{}
\end{prooftree}

\begin{prooftree}
\def\extraVskip{4pt}
\def\labelSpacing{4pt}
    \AxiomC{$\cdots$}
    \UnaryInfC{$1{:}nat,2{:}nat \vdash nat \rightsquigarrow (\lam x{:}nat.x)1$}
    \AxiomC{$\cdots$}
    \UnaryInfC{$1{:}nat,2{:}nat \vdash list \,nat \rightsquigarrow [(\lam x{:}nat.x)2]$}
    \RightLabel{\textsc{(G-Cons)}}
    \BinaryInfC{$1{:}nat,2{:}nat \vdash list \,nat \rightsquigarrow [(\lam x{:}nat.x)1, (\lam x{:}nat.x)2]$}
    \alwaysNoLine
    \UnaryInfC{}
\end{prooftree}

\begin{prooftree}
\def\extraVskip{4pt}
\def\labelSpacing{4pt}
    \AxiomC{$\cdots$}
    \UnaryInfC{$1{:}nat,2{:}nat \vdash list \,nat \rightsquigarrow [(\lam x{:}nat.x)1, (\lam x{:}nat.x)2]$}
    \AxiomC{$(\lam x{:}nat.x)1 =_\beta 1$}
    \def\extraVskip{1pt}
    \alwaysNoLine
    \UnaryInfC{$(\lam x{:}nat.x)2 =_\beta 2$}
    \RightLabel{\textsc{(L-Gen)}}
    \alwaysSingleLine
    \def\extraVskip{4pt}
    \BinaryInfC{$1{:}nat,2{:}nat \vdash list \,nat \rhd \langle\langle1\rangle,\langle2\rangle\rangle \rightsquigarrow [(\lam x{:}nat.x)1, (\lam x{:}nat.x)2]$}
    \RightLabel{\textsc{(L-Abs)}}
    \UnaryInfC{$\cdot \vdash list \,nat \!\to\! nat \rhd \langle\langle1,1\rangle,\langle2,2\rangle\rangle \rightsquigarrow [\lam x{:}nat.x, \lam x{:}nat.x]$}
    \RightLabel{\textsc{(L-Wrld)}}
    \UnaryInfC{$\cdot \vdash nat \!\to\! nat \rhd \langle\langle1,1\rangle,\langle2,2\rangle\rangle \rightsquigarrow \lam x{:}nat.x$}
    \alwaysNoLine
    \UnaryInfC{}
\end{prooftree}

\end{proof}

\begin{theorem}[\textsc{Learning polymorphic \textsc{identity}}] $\cdot \vdash \forall\alpha.\alpha \!\to\! \alpha \rhd \langle\Lambda\alpha.\langle z,z\rangle\rangle \rightsquigarrow \Lambda\alpha.\lam x{:}\alpha.x$
\label{learning-poly-identity}
\end{theorem}
\begin{proof}

\begin{prooftree}
\def\extraVskip{4pt}
\def\labelSpacing{4pt}
    \AxiomC{$x{:}nat \in \alpha, z{:}\alpha, x{:}\alpha$}
    \RightLabel{\textsc{(G-Var)}}
    \UnaryInfC{$\alpha, z{:}\alpha, x{:}\alpha \vdash \alpha \rightsquigarrow x$}
    \RightLabel{\textsc{(G-Abs)}}
    \UnaryInfC{$\alpha, z{:}\alpha \vdash \alpha\!\to\!\alpha \rightsquigarrow \lam x{:}\alpha.x$}
    \RightLabel{\textsc{(G-TAbs)}}
    \UnaryInfC{$\alpha, z{:}\alpha \vdash \forall\alpha.\alpha\!\to\!\alpha \rightsquigarrow \Lambda\alpha.\lam x{:}\alpha.x$}
    \RightLabel{\textsc{(G-Abs)}}
    \AxiomC{$\alpha, z{:}\alpha \vdash \alpha \rightsquigarrow \alpha$}
    \RightLabel{\textsc{(G-App)}}
    \BinaryInfC{$\alpha, z{:}\alpha \vdash \alpha\!\to\!\alpha \rightsquigarrow (\Lambda\alpha.\lam x{:}\alpha.x)\lceil\alpha\rceil$}
    \alwaysNoLine
    \UnaryInfC{}
\end{prooftree}

\begin{prooftree}
\def\extraVskip{4pt}
\def\labelSpacing{4pt}
    \AxiomC{$\cdots$}
    \UnaryInfC{$\alpha, z{:}\alpha \vdash \alpha\!\to\!\alpha \rightsquigarrow (\Lambda\alpha.\lam x{:}\alpha.x)\lceil\alpha\rceil$}
    \AxiomC{$z{:}\alpha \in \alpha, z{:}\alpha$}
    \RightLabel{\textsc{(G-Var)}}
    \UnaryInfC{$\alpha, z{:}\alpha \vdash \alpha \rightsquigarrow z$}
    \RightLabel{\textsc{(G-App)}}
    \BinaryInfC{$\alpha, z{:}\alpha \vdash \alpha \rightsquigarrow (\Lambda\alpha.\lam x{:}\alpha.x)\lceil\alpha\rceil z$}
    \alwaysNoLine
    \UnaryInfC{}
\end{prooftree}

\begin{prooftree}
\def\extraVskip{4pt}
\def\labelSpacing{4pt}
    \AxiomC{$\cdots$}
    \UnaryInfC{$\alpha, z{:}\alpha \vdash \alpha \rightsquigarrow (\Lambda\alpha.\lam x{:}\alpha.x)\lceil\alpha\rceil z$}
    \AxiomC{$\alpha, z{:}\alpha \vdash list \,\alpha \rightsquigarrow [\,]$}
    \RightLabel{\textsc{(G-Cons)}}
    \BinaryInfC{$\alpha, z{:}\alpha \vdash list\,\alpha \rightsquigarrow [(\Lambda\alpha.\lam x{:}\alpha.x)\lceil\alpha\rceil z]$}
    \alwaysNoLine
    \UnaryInfC{}
\end{prooftree}

\begin{prooftree}
\def\extraVskip{4pt}
\def\labelSpacing{4pt}
    \AxiomC{$\cdots$}
    \UnaryInfC{$\alpha, z{:}\alpha \vdash list\,\alpha \rightsquigarrow [(\Lambda\alpha.\lam x{:}\alpha.x)\lceil\alpha\rceil z]$}
    \AxiomC{$(\Lambda\alpha.\lam x{:}\alpha.x)\lceil\alpha\rceil z =_\beta z$}
    \RightLabel{\textsc{(L-Gen)}}
    \alwaysSingleLine
    \def\extraVskip{4pt}
    \BinaryInfC{$\alpha, z{:}\alpha \vdash list\,\alpha \rhd \langle\langle z\rangle\rangle \rightsquigarrow [(\Lambda\alpha.\lam x{:}\alpha.x)\lceil\alpha\rceil z]$}
    \RightLabel{\textsc{(L-Abs)}}
    \UnaryInfC{$\alpha \vdash list\,\alpha \!\to\! \alpha \rhd \langle\langle z,z\rangle\rangle \rightsquigarrow [(\Lambda\alpha.\lam x{:}\alpha.x)\lceil\alpha\rceil]$}
    \RightLabel{\textsc{(L-TAbs)}}
    \UnaryInfC{$\cdot \vdash list\,\forall\alpha.\alpha \!\to\! \alpha \rhd \langle\Lambda\alpha.\langle z,z\rangle\rangle \rightsquigarrow [\Lambda\alpha.\lam x{:}\alpha.x]$}
    \RightLabel{\textsc{(L-Wrld)}}
    \UnaryInfC{$\cdot \vdash \forall\alpha.\alpha \!\to\! \alpha \rhd \langle\Lambda\alpha.\langle z,z\rangle\rangle \rightsquigarrow \Lambda\alpha.\lam x{:}\alpha.x$}
    \alwaysNoLine
    \UnaryInfC{}
\end{prooftree}
\end{proof}

\begin{theorem}[\textsc{Learning \textsc{not}}] $\cdot \vdash bool\!\to\!bool \rhd \langle\langle true,false\rangle,\langle false,true\rangle\rangle \rightsquigarrow e$, where $e \equiv \lam x{:}bool.\text{case } x \text{ of inl(}true\text{)} \mapsto false \mid \text{inr(}false\text{)} \mapsto true$, $bool \equiv t + f$, $true : t$, and $false : f$.\\
\textbf{Proof isn't complete, but shows how we distribute examples when encountering a sum type. The part omitted has been showcased in the other proofs.}
\label{learning-not}
\end{theorem}
\begin{proof}

\begin{prooftree}
\def\extraVskip{4pt}
\def\labelSpacing{4pt}
    \AxiomC{$\cdots$}
    \AxiomC{$\cdots$}
    \BinaryInfC{$\cdot \vdash list\,t\!\to\!bool \rhd \langle\langle true,false\rangle\rangle \rightsquigarrow [\lam x{:}t.false]$}
    \alwaysNoLine
    \def\extraVskip{2pt}
    \UnaryInfC{$\cdot \vdash list\,f\!\to\!bool \rhd \langle\langle false,true\rangle\rangle \rightsquigarrow [\lam x{:}f.true]$}
    \alwaysSingleLine
    \def\extraVskip{4pt}
    \RightLabel{\textsc{(L-Sum)}}
    \UnaryInfC{$\cdot \vdash list\,bool\!\to\!bool \rhd \langle\langle true,false\rangle,\langle false,true\rangle\rangle \rightsquigarrow [e,e]$}
    \RightLabel{\textsc{(L-Wrld)}}
    \UnaryInfC{$\cdot \vdash bool\!\to\!bool \rhd \langle\langle true,false\rangle,\langle false,true\rangle\rangle \rightsquigarrow e$}
    \alwaysNoLine
    \UnaryInfC{}
\end{prooftree}
\end{proof}


\end{section}



\end{document}